#### 作用域Scope
作用域是代码的执行环境，全局执行环境即全局作用域，函数的执行环境即私有作用域，都为栈内存
* 执行环境
执行环境定义了变量或者函数有权访问的数据，决定了它们各自的行为；
每个执行环境都有一个与之关联的变量对象，此对象中保存着环境中定义的所有变量和函数；
无法在编写时直接获取该对象，但解析器在处理数据时会在后台使用它；

某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁；
全局执行环境知道应用程序退出时，如关闭浏览器或者网页，才会被销毁；

* 全局执行环境的执行环境对象会因为所在宿主环境不同而不同
> 在web浏览器中，全局执行环境被认为是window对象，所以所有的全局变量和函数都是作为window对象的属性和方法创建的
> 在node环境中，全局执行环境是global对象

* 私有作用域------函数执行都会形成一个私有作用域
* 全局作用域------页面一打开就会形成一个全局的作用域
* 私有变量------在私有作用域里面形成的变量（通过var声明；形参）
* 全局变量------在全局作用域形成的变量（var a = 22; 或者函数内没有声明，直接赋值的变量）

#### 作用域链
当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条）
> 作用域链的前端，始终都是当前执行的代码所在的环境的变量对象
> 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境
> 全局执行环境的变量对象始终都是作用域链上的最后一个对象

当在内部函数中，需要访问一个变量的时候，首先会访问函数本身的变量对象，是否有这个变量，如果没有，就会继续沿着作用域链向上查找，直到全局作用域，如果在某个变量对象中找到，则使用该变量对象中的变量值

由于变量的查找是沿着作用域链来实现的，所以称作用域链为 **变量查找的机制**


#### 作用域与执行上下文
js属于解释型语言，js的执行分为：解释和执行两个阶段
* 解释阶段
> 词法分析
> 语法分析
> 作用域规则确定

* 执行阶段
> 创建执行上下文
> 执行函数代码
> 垃圾回收

js解释阶段便会确定作用域规则，因此 **作用域在函数定义时就已经确定**了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是**this的指向是执行时确定的**，而作用域访问的变量是编写代码的结构确定的

##### 作用域与执行上下文之间最大的区别
* 作用域在定义时确定，并且不会改变
* 执行上下文在运行时确定，随时可能改变
> 一个作用域下可能包含若干个上下文环境
> 有可能从来没有过上下文环境（函数从来就没有被调用过）
> 有可能有过，当函数被调用完毕后，上下文环境被销毁了
> 有可能同时存在一个或多个（闭包）

同一作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值